import Data.List


-- Exercise 1 and 2

length2 :: [a] -> Int
length2 [] = 0
length2 (_:xs) = 1 + length2 xs

-- Exercise 3

mean :: Fractional a => [a] -> a
mean xs = (sum xs) / fromIntegral (length xs)

-- Exercise 4

palyndrome :: [a] -> [a]
palyndrome xs = xs ++ reverse xs

-- Exercise 5

isPalyndrome :: Eq a => [a] -> Bool
isPalyndrome xs = (reverse xs == xs)

-- Exercise 6

sortByLength :: [[a]] -> [[a]]
sortByLength = sortBy cmp
  where cmp lhs rhs = compare (length lhs) (length rhs)

-- Exercise 7

intersperse :: a -> [[a]] -> [a]
intersperse _ [] = []
intersperse _  [x] = x
intersperse sep (x:xs) = x ++ (sep : (Main.intersperse sep xs))

-- Exercise 8

data Tree a = Node a (Tree a) (Tree a)
            | Empty
            deriving (Show)

height :: Tree a -> Int
height Empty = 0
height (Node _ lhs rhs) = max (height lhs) (height rhs) + 1

-- Exercise 9

data Point = Point { x :: Double, y :: Double}
           deriving (Show, Eq)

data Direction = Left | Right | Parallel
               deriving (Show, Eq)

-- Exercise 10

turn :: Point -> Point -> Point -> Direction
turn a b c
  | prod > 0 = Main.Left
  | prod < 0 = Main.Right
  | otherwise = Parallel
  where prod = (x b - x a) * (y c - y a) - (x c - x a) * (y b - y a)

-- Exercise 11

turns :: [Point] -> [Direction]
turns [] = []
turns [_] = []
turns [_, _] = []
turns (a : (b: (c: ps))) = turn a b c : turns (b : c : ps)

-- Exercise 12

-- Graham Scan algorithm
-- it computes the convex hull generated by a given set of points

prod :: Point -> Point -> Double
prod v u = x v * x u + y v * y u

norm :: Point -> Double
norm v = sqrt $ prod v v

sub :: Point -> Point -> Point
sub p q = Point (x p - x q) (y p - y q)

-- prepare will compute the initial point p0 and order the remaining
-- points according to the angle between (p - p0) and the x axis
-- or their lenght, if the angles are equal

prepare :: [Point] -> (Point, [Point])
prepare points = (p0, sortByAngle p0 (filter ((/=) p0) points))
    where
        p0 = initial points
        initial [p] = p
        initial points = foldl cmp (head points) (tail points)
            where cmp p q
                     | (y p, x p) <= (y q, x q) = p
                     | otherwise = q
        sortByAngle p0 = sortBy cmp
            where cmp p q
                    | slope p /= slope q = compare (slope p) (slope q)
                    | otherwise = compare (norm (sub p p0)) (norm (sub q p0))
                  slope u = (y u - y p0) / (x u - x p0)


graham :: [Point] -> [Point]
-- corner cases
graham [p] = [p]
graham [p, q] = [p, q]
-- actual algorithm
graham points = performAlgorithm p0 sortedPoints
  where (p0, sortedPoints) = prepare points
        performAlgorithm p0 = foldl step [p0]
        step (u : (v : ps)) p = if turn v u p == Main.Left
                then [p, u, v] ++ ps
                else step (v : ps) p
        step ps p = p : ps
